// --------------------------------------------------------------------------------------
// JSON type provider - generate code for accessing inferred elements
// --------------------------------------------------------------------------------------
namespace ProviderImplementation

open System
open System.Collections.Generic
open FSharp.Quotations
open FSharp.Data
open FSharp.Data.Runtime
open FSharp.Data.Runtime.BaseTypes
open FSharp.Data.Runtime.StructuralTypes
open ProviderImplementation
open ProviderImplementation.JsonConversionsGenerator2
open ProviderImplementation.ProvidedTypes
open FSharp.Data.Runtime.StructuralInference
open UncheckedQuotations

#nowarn "10001"

/// Context that is used to generate the JSON types.
type internal JsonGenerationContext2 =
    { CultureStr: string
      TypeProviderType: ProvidedTypeDefinition
      // to nameclash type names
      UniqueNiceName: string -> string
      //IJsonDocumentType: Type
      //JsonValueType: Type
      JsonWrapperType: Type
      JsonRuntimeType: Type
      TypeCache: Dictionary<InferedType, ProvidedTypeDefinition>
      PreferDictionaries: bool
      GenerateConstructors: bool
      InferenceMode: InferenceMode'
      UnitsOfMeasureProvider: IUnitsOfMeasureProvider }

    static member Create
        (
            cultureStr,
            tpType,
            unitsOfMeasureProvider,
            inferenceMode,
            ?uniqueNiceName,
            ?typeCache,
            ?preferDictionaries
        ) =
        let uniqueNiceName =
            defaultArg uniqueNiceName (NameUtils.uniqueGenerator NameUtils.nicePascalName)

        let typeCache = defaultArg typeCache (Dictionary())
        let preferDictionaries = defaultArg preferDictionaries false

        JsonGenerationContext2.Create(
            cultureStr,
            tpType,
            uniqueNiceName,
            typeCache,
            preferDictionaries,
            true,
            inferenceMode,
            unitsOfMeasureProvider
        )

    static member Create
        (
            cultureStr,
            tpType,
            uniqueNiceName,
            typeCache,
            preferDictionaries,
            generateConstructors,
            inferenceMode,
            unitsOfMeasureProvider
        ) =
        { CultureStr = cultureStr
          TypeProviderType = tpType
          UniqueNiceName = uniqueNiceName
          //IJsonDocumentType = typeof<IJsonDocument2>
          //JsonValueType = typeof<JsonValue2>
          JsonWrapperType = typeof<JsonWrapper>
          JsonRuntimeType = typeof<JsonRuntime2>
          TypeCache = typeCache
          PreferDictionaries = preferDictionaries
          GenerateConstructors = generateConstructors
          InferenceMode = inferenceMode
          UnitsOfMeasureProvider = unitsOfMeasureProvider }

    member x.MakeOptionType(typ: Type) =
        typedefof<option<_>>.MakeGenericType typ

/// Output of generateJsonType: contains the type that should be generated by the provider to represent the json sample.
type internal JsonGenerationResult2 =
    {
        /// High level type representing the underlying json entity in the type provider. (possibly a provided type that will be erased to something else)
        RepresentationType: Type
        /// Expr taking the erased/json type as input (depends on the ConversionCallingType) and returning the high level RepresentationType as output.
        /// A converter is required when the erased type is not expected by the caller (i.e. not a JsonWrapper).
        OptionalConverter: (Expr -> Expr) option
    /// Represents the input type of the Converter (a json type).
    //ConversionCallingType: JsonConversionCallingType2
    }

    member x.Convert = defaultArg x.OptionalConverter id

    /// Expr wrapping the Convert function.
    /// This assumes the input is a IJsonDocument.
    member x.ConverterFunc ctx =
        ReflectionHelpers.makeDelegate x.Convert ctx.JsonWrapperType

    /// Type representing the underlying json entity, after erasure.
    /// (if the RepresentationType was a provided type, the RepresentationTypeErased will simply be a JsonWrapper)
    /// It's necessary to use this type instead of the RepresentationType directly when calling generic methods with a generic type parameter.
    /// If the generic type parameter provided is a provided type before erasure, it will error out at design time, saying that it could not find the generic type.
    member x.RepresentationTypeErased(ctx: JsonGenerationContext2) =
        // TODO: unit test that checks that it works regardless of the depth.
        // e.g. with {"a": [[[[{"b":42}]]], [[[{"b":42}]]]]}
        // (this previous example fails with the JsonProvider non-recursive implementation)
        let inline isOption (t: Type) = t.Name.StartsWith("FSharpOption`1")
        let inline extractFirstGenericArgument (t: Type) = t.GetGenericArguments()[0]
        let rec recurse (typ: Type) =
            if typ.IsArray then
                let result: Type = recurse (typ.GetElementType())
                result.MakeArrayType()
            else if isOption typ then
                let result: Type = recurse (extractFirstGenericArgument typ)
                ctx.MakeOptionType result
            else
                match typ with
                | :? ProvidedTypeDefinition as ptd ->
                    if isOption ptd.BaseType then
                        let result: Type = recurse (extractFirstGenericArgument ptd.BaseType)
                        ctx.MakeOptionType result
                    //ctx.MakeOptionType ctx.JsonWrapperType
                    else
                        ctx.JsonWrapperType
                | _ -> typ

        recurse x.RepresentationType

module JsonTypeBuilder2 =

    let (?) = QuotationBuilder.(?)

    module internal List =
        let unzip4 l =
            let a, b, cd = List.unzip3 (List.map (fun (a, b, c, d) -> (a, b, (c, d))) l)
            let c, d = List.unzip cd
            a, b, c, d

        let unzip5 l =
            let a, b, cde = List.unzip3 (List.map (fun (a, b, c, d, e) -> (a, b, (c, d, e))) l)
            let c, d, e = List.unzip3 cde
            a, b, c, d, e

    let internal aggregateTypes =
        Seq.fold (StructuralInference.subtypeInfered false) InferedType.Top

    let internal findOriginalPrimitiveType inferedType =
        let (|SingleTypeCollection|_|) =
            function
            | InferedType.Collection ([ singleTag ], types, _) ->
                let _, singleType = types[singleTag]
                Some singleType
            | _ -> None

        match inferedType with
        | InferedType.Primitive (_, _, _, _, originalType) -> Some originalType
        | SingleTypeCollection (InferedType.Primitive (_, _, _, _, originalType)) -> Some originalType
        | _ -> None

    /// Checks if a type was already created for the inferedType before creating a new one.
    let internal getOrCreateProvidedType ctx inferedType createType =

        // normalize properties of the inferedType which don't affect code generation
        let rec normalize topLevel =
            function
            | InferedType.Heterogeneous (map, _) ->
                map
                |> Map.map (fun _ inferedType -> normalize false inferedType)
                |> (fun x -> InferedType.Heterogeneous(x, Mandatory))
            | InferedType.Collection (order, types, optional) ->
                InferedType.Collection(
                    order,
                    Map.map (fun _ (multiplicity, inferedType) -> multiplicity, normalize false inferedType) types,
                    optional
                )
            | InferedType.Record (_, props, optional) ->
                let props =
                    props
                    |> List.map (fun { Name = name; Type = inferedType } ->
                        { Name = name
                          Type = normalize false inferedType })
                // optional only affects the parent, so at top level always set to optional regardless of the actual value
                InferedType.Record(
                    None,
                    props,
                    InferedOptionality.Merge(optional, InferedOptionality.FromBool(topLevel))
                )
            | InferedType.Primitive (typ, unit, optional, shouldOverrideOnMerge, originalType) when
                typ = typeof<Bit0>
                || typ = typeof<Bit1>
                || typ = typeof<Bit>
                ->
                InferedType.Primitive(typeof<int>, unit, optional, shouldOverrideOnMerge, originalType)
            | x -> x

        let inferedType = normalize true inferedType

        match ctx.TypeCache.TryGetValue inferedType with
        | true, typ -> typ
        | _ ->
            let typ = createType ()
            ctx.TypeCache.Add(inferedType, typ)
            typ

    //let internal replaceJDocWithJValue (ctx: JsonGenerationContext2) (typ: Type) =
    //    if typ = ctx.IJsonDocumentType then
    //        ctx.JsonValueType
    //    elif typ.IsArray
    //         && typ.GetElementType() = ctx.IJsonDocumentType then
    //        ctx.JsonValueType.MakeArrayType()
    //    elif typ.IsGenericType
    //         && typ.GetGenericArguments() = [| ctx.IJsonDocumentType |] then
    //        typ.GetGenericTypeDefinition().MakeGenericType ctx.JsonValueType
    //    else
    //        typ

    ///// Common code that is shared by code generators that generate
    ///// "Choice" type. This is parameterized by the types (choices) to generate,
    ///// by functions that get the multiplicity and the type tag for each option
    ///// and also by function that generates the actual code.
    //let rec internal generateMultipleChoiceType
    //    ctx
    //    types
    //    containsOptional
    //    nameOverride
    //    (getterCodeGenerator: _ -> _ -> _ -> Expr)
    //    =

    //    let types =
    //        types
    //        |> Seq.map (fun (KeyValue (tag, (_, inferedType))) -> tag, inferedType)
    //        |> Seq.sortBy (fun (tag, _) -> tag)
    //        |> Seq.toArray

    //    if types.Length <= 1 then
    //        failwithf "generateMultipleChoiceType: Invalid choice type: %A" types

    //    for _, inferedType in types do
    //        match inferedType with
    //        | InferedType.Null _
    //        | InferedType.Top
    //        | InferedType.Heterogeneous _ -> failwithf "generateMultipleChoiceType: Unsupported type: %A" inferedType
    //        | x when x.IsExplicitlyOptional OptionalCollection.Disallow -> failwithf "generateMultipleChoiceType: Type shouldn't be optional: %A" inferedType
    //        | _ -> ()

    //    let typeName =
    //        if not (String.IsNullOrEmpty nameOverride) then
    //            nameOverride
    //        else
    //            let getTypeName (tag: InferedTypeTag, inferedType) =
    //                match inferedType with
    //                | InferedType.Primitive (typ, _, _, _, _) ->
    //                    if typ = typeof<int>
    //                        || typ = typeof<Bit0>
    //                        || typ = typeof<Bit1> then
    //                        "Int"
    //                    elif typ = typeof<int64> then
    //                        "Int64"
    //                    elif typ = typeof<decimal> then
    //                        "Decimal"
    //                    elif typ = typeof<float> then
    //                        "Float"
    //                    else
    //                        tag.NiceName
    //                | _ -> tag.NiceName

    //            types
    //            |> Array.map getTypeName
    //            |> String.concat "Or"
    //        |> ctx.UniqueNiceName

    //    // Generate new type for the heterogeneous type.
    //    // TODO use an option type here, like we do the xml provider.
    //    // (is it possible? with the xml provider it's used only as an intermediate value: the Choice type generated for attributes is meaningless without the type generated for the whole record, and this one is backed by an xelement)
    //    let objectTy =
    //        ProvidedTypeDefinition(typeName, Some(ctx.MakeOptionType(ctx.IJsonDocumentType)), hideObjectMethods = true, nonNullable = true)

    //    ctx.TypeProviderType.AddMember objectTy

    //    // to nameclash property names
    //    let makeUnique = NameUtils.uniqueGenerator NameUtils.nicePascalName
    //    makeUnique "JsonValue" |> ignore

    //    let members =
    //        [ for tag, inferedType in types ->

    //            let result = generateJsonType ctx false false "" inferedType

    //            let name, typ, constructorType =
    //                let propName =
    //                    match tag with
    //                    | InferedTypeTag.Record _ -> "Record"
    //                    | _ -> tag.NiceName
    //                makeUnique propName,
    //                ctx.MakeOptionType result.RepresentationType,
    //                replaceJDocWithJValue ctx result.RepresentationType

    //            ProvidedProperty(name, typ, getterCode = getterCodeGenerator result tag.Code),
    //            (ProvidedParameter(NameUtils.niceCamelName name, constructorType), findOriginalPrimitiveType inferedType) ]

    //    let properties, paramsTuple = List.unzip members
    //    objectTy.AddMembers properties

    //    if ctx.GenerateConstructors then

    //        let cultureStr = ctx.CultureStr

    //        for param, originalPrimitiveType in paramsTuple do
    //            let ctorCode (Singleton arg: Expr list) = <@@ () @@>
    //                //let arg = Expr.Coerce(arg, typeof<obj>)
    //                //let serializedOriginalPrimitiveType =
    //                //    originalPrimitiveType |> PrimitiveType.ToInt
    //                //<@@ Some <| JsonRuntime2.CreateValue((%%arg: obj), serializedOriginalPrimitiveType, cultureStr) @@>

    //            let ctor = ProvidedConstructor([ param ], invokeCode = ctorCode)
    //            objectTy.AddMember ctor

    //        match containsOptional with
    //        | InferedOptionality.Optional NullKind.NoValue ->
    //            let defaultCtor =
    //                let ctorCode _ = <@@ None @@>

    //                ProvidedConstructor([], invokeCode = ctorCode)

    //            objectTy.AddMember defaultCtor
    //        | InferedOptionality.Optional NullKind.NullToken ->
    //            let defaultCtor =
    //                let ctorCode _ = <@@ () @@>
    //                    //let noPrimitiveType = None |> PrimitiveType.ToInt
    //                    //<@@ Some <| JsonRuntime2.CreateValue(null :> obj, noPrimitiveType, cultureStr) @@>

    //                ProvidedConstructor([], invokeCode = ctorCode)

    //            objectTy.AddMember defaultCtor
    //        | _ -> ()

    //        let ctorCode (Singleton arg) =
    //            <@@ Some <| JsonDocument2.Create((%%arg: JsonValue2), "") @@>

    //        let ctor =
    //            ProvidedConstructor([ ProvidedParameter("jsonValue", ctx.JsonValueType) ], invokeCode = ctorCode)

    //        objectTy.AddMember ctor

    //    objectTy

    /// Recursively walks over inferred type information and
    /// generates types for read-only access to the document
    let rec internal generateJsonType
        (ctx: JsonGenerationContext2)
        canPassAllConversionCallingTypes
        optionalityHandledByParent
        nameOverride
        inferedType
        =

        match inferedType with

        | InferedType.Top
        | InferedType.Null _ ->

            let conv = fun (arg: Expr) -> <@@ JsonRuntime2.GetAsOptional(%%arg) @@>

            // Return the underlying JsonDocument without change
            // (assume it can be anything)
            { RepresentationType = ctx.JsonWrapperType |> ctx.MakeOptionType
              OptionalConverter = Some conv
            //ConversionCallingType = JsonDocument
            }

        | InferedType.Primitive (inferedType, unit, optional, _, _) ->

            //let typ, conv, conversionCallingType =
            //    PrimitiveInferedValue.Create(inferedType, optional, unit)
            //    |> convertJsonValue ctx.CultureStr canPassAllConversionCallingTypes

            //{ RepresentationType = typ
            //  OptionalConverter = Some conv
            //  //ConversionCallingType = conversionCallingType
            //  }

            //let conv =
            //    fun (arg: Expr) ->
            //        // TODO: generalize this:
            //        <@@ JsonRuntime2.GetAsOptional(%%arg) |> Option.map (fun x -> x.JsonNode.GetValue<decimal>()) @@>

            if optional.IsOptional then
                { RepresentationType = inferedType |> ctx.MakeOptionType
                  OptionalConverter =
                    Some(fun arg ->
                        ctx.JsonRuntimeType?(nameof (JsonRuntime2.GetPrimitiveValueAsOptional)) (inferedType) (arg)) }
            else
                { RepresentationType = inferedType
                  OptionalConverter =
                    Some(fun arg -> ctx.JsonRuntimeType?(nameof (JsonRuntime2.GetPrimitiveValue)) (inferedType) (arg)) }

        | InferedType.Collection (_, types, optional) ->

            //if optional.IsOptional && not optionalityHandledByParent then
            //    failwithf "generateJsonType: optionality not handled for %A" inferedType

            let elementType =
                types
                |> Seq.map (fun (KeyValue (_, (_, typ))) -> typ)
                |> aggregateTypes

            let elementTypeResult =
                let result = generateJsonType ctx false true nameOverride elementType
                result

            //{ RepresentationType = elementTypeResult.RepresentationType.MakeArrayType()
            //  OptionalConverter = Some (fun arg ->
            //      ctx.JsonRuntimeType?(nameof (JsonRuntime2.GetArrayValues))
            //          (elementTypeResult.RepresentationTypeErased ctx)
            //          //(ctx.MakeOptionType ctx.JsonWrapperType) // dirty test (it works!)
            //          (arg, elementTypeResult.ConverterFunc ctx))
            //  //ConversionCallingType = JsonDocument
            //  }

            if optional.IsOptional then
                { RepresentationType =
                    elementTypeResult.RepresentationType.MakeArrayType()
                    |> ctx.MakeOptionType
                  OptionalConverter =
                    Some(fun arg ->
                        ctx.JsonRuntimeType?(nameof (JsonRuntime2.GetArrayValuesAsOptional))
                            (elementTypeResult.RepresentationTypeErased ctx)
                            (arg, elementTypeResult.ConverterFunc ctx)) }
            else
                { RepresentationType = elementTypeResult.RepresentationType.MakeArrayType()
                  OptionalConverter =
                    Some(fun arg ->
                        ctx.JsonRuntimeType?(nameof (JsonRuntime2.GetArrayValues))
                            (elementTypeResult.RepresentationTypeErased ctx)
                            (arg, elementTypeResult.ConverterFunc ctx)) }


        //let conv =
        //    fun (jDoc: Expr) ->
        //        ctx.JsonRuntimeType?(nameof (JsonRuntime2.ConvertOptionalValue))
        //            (result.RepresentationTypeErased ctx)
        //            (jDoc, result.ConverterFunc ctx)

        //// TODO: check calling convention like we do for record properties. it could be jdoc option for heterogeneous types

        //let resultIsAlreadyOptional = result.RepresentationType.Name.StartsWith("FSharpOption`1") // TODO: do this properly somehow? (primitive types handle optionality, but not other types)
        //if elementType.IsExplicitlyOptional OptionalCollection.Allow && not resultIsAlreadyOptional then
        //    { RepresentationType = ctx.MakeOptionType result.RepresentationType
        //      OptionalConverter = Some conv
        //      //ConversionCallingType = JsonDocument
        //      }
        //else
        //    result

        // TODO: generate ctor to be able to generate optional nested collections
        //    makeUnique (NameUtils.pluralize tag.NiceName),
        //    result.RepresentationType.MakeArrayType(),
        //    (replaceJDocWithJValue ctx result.RepresentationType).MakeArrayType()

        //// TODO: relying on the optionalityHandledByParent parameter seems a bit brittle.
        //if optional.IsOptional && not optionalityHandledByParent then
        //    { RepresentationType = elementTypeResult.RepresentationType.MakeArrayType() |> ctx.MakeOptionType
        //      OptionalConverter = Some (fun (jDoc: Expr) ->
        //          ctx.JsonRuntimeType?(nameof (JsonRuntime2.TryConvertArray))
        //              (elementTypeResult.RepresentationTypeErased ctx)
        //              (jDoc, elementTypeResult.ConverterFunc ctx))
        //      //ConversionCallingType = JsonDocument
        //      }
        //else
        //    { RepresentationType = elementTypeResult.RepresentationType.MakeArrayType()
        //      OptionalConverter = Some (fun (jDoc: Expr) ->
        //          ctx.JsonRuntimeType?(nameof (JsonRuntime2.ConvertArray))
        //              (elementTypeResult.RepresentationTypeErased ctx)
        //              (jDoc, elementTypeResult.ConverterFunc ctx))
        //      //ConversionCallingType = JsonDocument
        //      }

        | InferedType.Record (name, props, optional) ->
            let providedRecordType =
                getOrCreateProvidedType ctx inferedType (fun () ->

                    //if optional.IsOptional && not optionalityHandledByParent then
                    //    failwithf "generateJsonType: optionality not handled for %A" inferedType

                    let name =
                        if String.IsNullOrEmpty nameOverride then
                            match name with
                            | Some name -> name
                            | _ -> "Record"
                        else
                            nameOverride
                        |> ctx.UniqueNiceName

                    // Generate new type for the record
                    let objectTy =
                        ProvidedTypeDefinition(
                            name,
                            Some ctx.JsonWrapperType,
                            hideObjectMethods = true,
                            nonNullable = true
                        )

                    ctx.TypeProviderType.AddMember(objectTy)

                    // to nameclash property names
                    let makeUnique = NameUtils.uniqueGenerator NameUtils.nicePascalName

                    makeUnique (nameof (Unchecked.defaultof<JsonWrapper>.JsonNode))
                    |> ignore

                    //let inferedKeyValueType =

                    //    let dropRecordsNames infType =

                    //        let dropRecordName infType =
                    //            match infType with
                    //            | InferedType.Record (_, fields, opt) -> InferedType.Record(None, fields, opt)
                    //            | _ -> infType

                    //        let dropTagName tag =
                    //            match tag with
                    //            | InferedTypeTag.Record (Some _) -> InferedTypeTag.Record None
                    //            | _ -> tag

                    //        let infType = dropRecordName infType

                    //        match infType with
                    //        | InferedType.Collection (order, types, optional) ->
                    //            // Records in collections have the parent property as name.
                    //            // We drop it too so they can be merged into a unified type.
                    //            let order = order |> List.map dropTagName

                    //            let types =
                    //                types
                    //                |> Map.toSeq
                    //                |> Seq.map (fun (tag, (multiplicity, typ)) ->
                    //                    let tag = dropTagName tag
                    //                    let typ = dropRecordName typ
                    //                    tag, (multiplicity, typ))
                    //                |> Map.ofSeq

                    //            InferedType.Collection(order, types, optional)
                    //        | _ -> infType

                    //    if not ctx.PreferDictionaries then
                    //        None
                    //    else
                    //        let infKeyType =
                    //            [ for prop in props ->
                    //                  StructuralInference.inferPrimitiveType
                    //                      ctx.UnitsOfMeasureProvider
                    //                      ctx.InferenceMode
                    //                      (TextRuntime.GetCulture ctx.CultureStr)
                    //                      prop.Name
                    //                      None
                    //                      false
                    //                      BooleanParsing.Strict ]
                    //            |> aggregateTypes

                    //        match infKeyType with
                    //        | InferedType.Primitive (typ = typ) when typ <> typeof<string> ->
                    //            let inferValueType =
                    //                ([ for prop in props -> prop.Type |> dropRecordsNames ]
                    //                 |> aggregateTypes)
                    //                    // Optional properties in the initial record should translate
                    //                    // to simply missing values in the dictionary, not an optional type.
                    //                    .DropOptionality()

                    //            Some(infKeyType, inferValueType)
                    //        | _ -> None

                    //match inferedKeyValueType with
                    //| Some (inferedKeyType, inferedValueType) ->
                    //    // Add all record fields as dictionary items
                    //    let valueName = name + "Value"

                    //    let keyResult = generateJsonType ctx false true "" inferedKeyType
                    //    let valueResult = generateJsonType ctx false true valueName inferedValueType
                    //    let valueRepresentationTypeErased = valueResult.RepresentationTypeErased ctx

                    //    let tupleType =
                    //        Microsoft.FSharp.Reflection.FSharpType.MakeTupleType(
                    //            [| keyResult.RepresentationType; valueResult.RepresentationType |]
                    //        )

                    //    let itemsSeqType = typedefof<_ seq>.MakeGenericType ([| tupleType |])

                    //    let itemsGetter (Singleton jDoc) =
                    //        ctx.JsonRuntimeType?(nameof (JsonRuntime2.ConvertRecordToDictionary))
                    //            (keyResult.RepresentationType, valueRepresentationTypeErased)
                    //            (jDoc, keyResult.ConverterFunc ctx, valueResult.ConverterFunc ctx)

                    //    let keysGetter (Singleton jDoc) =
                    //        ctx.JsonRuntimeType?(nameof (JsonRuntime2.GetKeysFromInferedDictionary))
                    //            (keyResult.RepresentationType)
                    //            (jDoc, keyResult.ConverterFunc ctx)

                    //    let valuesGetter (Singleton jDoc) =
                    //        ctx.JsonRuntimeType?(nameof (JsonRuntime2.GetValuesFromInferedDictionary))
                    //            (valueRepresentationTypeErased)
                    //            (jDoc, valueResult.ConverterFunc ctx)

                    //    let (|Doubleton|) =
                    //        function
                    //        | [ f; s ] -> f, s
                    //        | _ -> failwith "Parameter mismatch"

                    //    let itemGetter (Doubleton (jDoc, key)) =
                    //        ctx.JsonRuntimeType?(nameof (JsonRuntime2.GetValueByKeyFromInferedDictionary))
                    //            (keyResult.RepresentationType, valueRepresentationTypeErased)
                    //            (jDoc, keyResult.ConverterFunc ctx, valueResult.ConverterFunc ctx, key)

                    //    let tryFindCode (Doubleton (jDoc, key)) =
                    //        ctx.JsonRuntimeType?(nameof (JsonRuntime2.TryGetValueByKeyFromInferedDictionary))
                    //            (keyResult.RepresentationType, valueRepresentationTypeErased)
                    //            (jDoc, keyResult.ConverterFunc ctx, valueResult.ConverterFunc ctx, key)

                    //    let containsKeyCode (Doubleton (jDoc, key)) =
                    //        ctx.JsonRuntimeType?(nameof (JsonRuntime2.InferedDictionaryContainsKey))
                    //            (keyResult.RepresentationType)
                    //            (jDoc, keyResult.ConverterFunc ctx, key)

                    //    let countGetter (Singleton jDoc) =
                    //        <@@ JsonRuntime2.GetRecordProperties(%%jDoc).Length @@>

                    //    let isEmptyGetter (Singleton jDoc) =
                    //        <@@ JsonRuntime2.GetRecordProperties(%%jDoc).Length = 0 @@>

                    //    [ ProvidedProperty("Items", itemsSeqType, getterCode = itemsGetter)
                    //      ProvidedProperty("Keys", keyResult.RepresentationType.MakeArrayType(), getterCode = keysGetter)
                    //      ProvidedProperty("Values", valueResult.RepresentationType.MakeArrayType(), getterCode = valuesGetter)
                    //      ProvidedProperty(
                    //          "Item",
                    //          valueResult.RepresentationType,
                    //          getterCode = itemGetter,
                    //          indexParameters = [ ProvidedParameter("key", keyResult.RepresentationType) ]
                    //      )
                    //      ProvidedProperty("Count", typeof<int>, getterCode = countGetter)
                    //      ProvidedProperty("IsEmpty", typeof<bool>, getterCode = isEmptyGetter) ]
                    //    |> objectTy.AddMembers

                    //    [ ProvidedMethod(
                    //          "TryFind",
                    //          [ ProvidedParameter("key", keyResult.RepresentationType) ],
                    //          valueResult.RepresentationType |> ctx.MakeOptionType,
                    //          tryFindCode
                    //      )
                    //      ProvidedMethod(
                    //          "ContainsKey",
                    //          [ ProvidedParameter("key", keyResult.RepresentationType) ],
                    //          typeof<bool>,
                    //          containsKeyCode
                    //      ) ]
                    //    |> objectTy.AddMembers

                    //    if ctx.GenerateConstructors then
                    //        let conv (value: Expr) =
                    //            let value = ProviderHelpers.some keyResult.RepresentationType value

                    //            ConversionsGenerator.getBackConversionQuotation
                    //                ""
                    //                ctx.CultureStr
                    //                keyResult.RepresentationType
                    //                value
                    //            :> Expr

                    //        let ctorCode (args: Expr list) =
                    //            let kvSeq = args.Head
                    //            let convFunc = ReflectionHelpers.makeDelegate conv keyResult.RepresentationType
                    //            let cultureStr = ctx.CultureStr

                    //            let originalValueType =
                    //                findOriginalPrimitiveType inferedValueType
                    //                |> PrimitiveType.ToInt
                    //                |> Expr.Value

                    //            ctx.JsonRuntimeType?(nameof (JsonRuntime2.CreateRecordFromDictionary))
                    //                (keyResult.RepresentationType, valueRepresentationTypeErased)
                    //                (kvSeq, cultureStr, convFunc, originalValueType)

                    //        let ctor =
                    //            ProvidedConstructor([ ProvidedParameter("items", itemsSeqType) ], ctorCode)

                    //        objectTy.AddMember ctor

                    //    ()
                    //| None ->
                    // Add all record fields as properties
                    let members =
                        [ for prop in props ->

                              let propResult = generateJsonType ctx true true "" prop.Type
                              let propName = prop.Name
                              //let optionalityHandledByProperty = propResult.ConversionCallingType <> JsonDocument

                              let getter (Singleton arg) = // <@@ () @@>
                                  <@@ JsonRuntime2.GetRecordProperty(%%arg, propName) @@>
                                  |> propResult.Convert


                              //    if optionalityHandledByProperty then

                              //        propResult.Convert
                              //        <| if propResult.ConversionCallingType = JsonValueOptionAndPath then
                              //                <@@ JsonRuntime2.TryGetPropertyUnpackedWithPath(%%jDoc, propName) @@>
                              //            else if propResult.ConversionCallingType = JsonDocumentOption then
                              //            <@@ JsonRuntime2.TryGetPropertyPacked(%%jDoc, propName) @@>
                              //            else
                              //                <@@ JsonRuntime2.TryGetPropertyUnpacked(%%jDoc, propName) @@>

                              //    elif prop.Type.IsExplicitlyOptional OptionalCollection.Allow then

                              //        match propResult.OptionalConverter with
                              //        | Some _ ->
                              //            //TODO: not covered in tests
                              //            ctx.JsonRuntimeType?(nameof (JsonRuntime2.ConvertOptionalProperty))
                              //                (propResult.RepresentationTypeErased ctx)
                              //                (jDoc, propName, propResult.ConverterFunc ctx)

                              //        | None -> <@@ JsonRuntime2.TryGetPropertyPacked(%%jDoc, propName) @@>

                              //    else

                              //        propResult.Convert
                              //        <| match prop.Type with
                              //            | InferedType.Collection _
                              //            | InferedType.Heterogeneous _
                              //            | InferedType.Top
                              //            | InferedType.Null _ ->
                              //                <@@ JsonRuntime2.GetPropertyPackedOrNull(%%jDoc, propName) @@>
                              //            | _ -> <@@ JsonRuntime2.GetPropertyPacked(%%jDoc, propName) @@>

                              let convertedType =
                                  if prop.Type.IsExplicitlyOptional OptionalCollection.Allow
                                  //&& not optionalityHandledByProperty
                                  then
                                      propResult.RepresentationType
                                      |> ctx.MakeOptionType
                                  else
                                      propResult.RepresentationType

                              let name = makeUnique prop.Name

                              prop.Name,
                              ProvidedProperty(name, convertedType, getterCode = getter),
                              ProvidedParameter(NameUtils.niceCamelName name, convertedType),  //replaceJDocWithJValue ctx convertedType),
                              findOriginalPrimitiveType prop.Type,
                              prop.Type.GetOptionality() ]

                    let names, properties, parameters, originalPrimitiveTypes, optionality =
                        List.unzip5 members

                    objectTy.AddMembers properties

                    if ctx.GenerateConstructors then
                        let ctorCode (args: Expr list) = <@@ () @@>
                        //let properties =
                        //    Expr.NewArray(
                        //        typeof<string * obj * int * bool>,
                        //        args
                        //        |> List.mapi (fun i a ->
                        //            let name = names[i]

                        //            let serializedOriginalPrimitiveType =
                        //                originalPrimitiveTypes[i] |> PrimitiveType.ToInt

                        //            let arg = Expr.Coerce(a, typeof<obj>)
                        //            let doNotWriteNulls =
                        //                match optionality[i] with
                        //                | Mandatory -> false
                        //                | Optional NullKind.NullToken -> false
                        //                | Optional NullKind.NoValue -> true
                        //            <@@ (name, %%arg, serializedOriginalPrimitiveType, doNotWriteNulls) @@>)
                        //    )

                        //let cultureStr = ctx.CultureStr

                        //<@@ JsonRuntime2.CreateRecord(%%properties, cultureStr) @@>

                        let ctor = ProvidedConstructor(parameters, invokeCode = ctorCode)
                        objectTy.AddMember ctor

                    ()

                    if ctx.GenerateConstructors then
                        let ctorCode (Singleton arg: Expr list) = <@@ () @@>
                        //<@@ JsonDocument2.Create((%%arg: JsonValue2), "") @@>

                        let ctorParams = [ ProvidedParameter("jsonValue", ctx.JsonWrapperType) ]
                        let ctor = ProvidedConstructor(ctorParams, ctorCode)
                        objectTy.AddMember ctor

                    objectTy)

            if optional.IsOptional then
                { RepresentationType = providedRecordType |> ctx.MakeOptionType
                  OptionalConverter = Some(fun (arg: Expr) -> <@@ JsonRuntime2.GetAsOptional(%%arg) @@>) }
            else
                { RepresentationType = providedRecordType
                  OptionalConverter = None
                //Some (fun arg ->
                //ctx.JsonRuntimeType?(nameof(JsonRuntime2.GetPrimitiveValue))
                //    (result.RepresentationType)
                //    (arg))
                }

        | InferedType.Heterogeneous (types, containsOptional) ->
            let providedHeterogeneousType =
                getOrCreateProvidedType ctx inferedType (fun () ->

                    // Generate a choice type that always calls `TryGetValueByTypeTag`
                    let types =
                        types
                        |> Map.map (fun _ v -> InferedMultiplicity.OptionalSingle, v)

                    let types =
                        types
                        |> Seq.map (fun (KeyValue (tag, (_, inferedType))) -> tag, inferedType)
                        |> Seq.sortBy (fun (tag, _) -> tag)
                        |> Seq.toArray

                    if types.Length <= 1 then
                        failwithf "generateMultipleChoiceType: Invalid choice type: %A" types

                    for _, inferedType in types do
                        match inferedType with
                        | InferedType.Null _
                        | InferedType.Top
                        | InferedType.Heterogeneous _ ->
                            failwithf "generateMultipleChoiceType: Unsupported type: %A" inferedType
                        | x when x.IsExplicitlyOptional OptionalCollection.Disallow ->
                            failwithf "generateMultipleChoiceType: Type shouldn't be optional: %A" inferedType
                        | _ -> ()

                    let typeName =
                        if not (String.IsNullOrEmpty nameOverride) then
                            nameOverride
                        else
                            let getTypeName (tag: InferedTypeTag, inferedType) =
                                match inferedType with
                                | InferedType.Primitive (typ, _, _, _, _) ->
                                    if typ = typeof<int>
                                       || typ = typeof<Bit0>
                                       || typ = typeof<Bit1> then
                                        "Int"
                                    elif typ = typeof<int64> then
                                        "Int64"
                                    elif typ = typeof<decimal> then
                                        "Decimal"
                                    elif typ = typeof<float> then
                                        "Float"
                                    else
                                        tag.NiceName
                                | _ -> tag.NiceName

                            types
                            |> Array.map getTypeName
                            |> String.concat "Or"
                        |> ctx.UniqueNiceName

                    // Generate new type for the heterogeneous type.
                    // TODO use an option type here, like we do the xml provider.
                    // (is it possible? with the xml provider it's used only as an intermediate value: the Choice type generated for attributes is meaningless without the type generated for the whole record, and this one is backed by an xelement)
                    let objectTy =
                        ProvidedTypeDefinition(
                            typeName,
                            Some(ctx.JsonWrapperType |> ctx.MakeOptionType),
                            hideObjectMethods = true,
                            nonNullable = true
                        )

                    ctx.TypeProviderType.AddMember objectTy

                    // to nameclash property names
                    let makeUnique = NameUtils.uniqueGenerator NameUtils.nicePascalName

                    makeUnique (nameof (Unchecked.defaultof<JsonWrapper>.JsonNode))
                    |> ignore

                    let members =
                        [ for tag, inferedType in types ->

                              let result = generateJsonType ctx false false "" inferedType

                              let name, typ, constructorType =
                                  let propName =
                                      match tag with
                                      | InferedTypeTag.Record _ -> "Record"
                                      | _ -> tag.NiceName

                                  makeUnique propName,
                                  result.RepresentationType |> ctx.MakeOptionType,
                                  result.RepresentationType //replaceJDocWithJValue ctx result.RepresentationType

                              let getter =
                                  fun (Singleton arg) ->
                                      //let cultureStr = ctx.CultureStr

                                      //ctx.JsonRuntimeType?(nameof (JsonRuntime2.TryGetValueByTypeTag))
                                      //    (result.RepresentationTypeErased ctx)
                                      //    (jDoc, cultureStr, tag.Code, result.ConverterFunc ctx)
                                      // TODO: doesn't work:
                                      //<@@ (%%converterFunc: Func<JsonWrapper,decimal>).Invoke(%%jDoc) @@>
                                      //<@@ () @@>

                                      //// works!!!
                                      //let convert =
                                      //    let firstStep = result.ConverterFunc ctx
                                      //    match tag with
                                      //    | InferedTypeTag.Number ->
                                      //        <@@ Func<JsonWrapper,decimal>(fun x -> (%%firstStep: Func<JsonWrapper,decimal>).Invoke(x) |> decimal) @@>
                                      //    | InferedTypeTag.String ->
                                      //        <@@ Func<JsonWrapper,string>(fun x -> (%%firstStep: Func<JsonWrapper,string>).Invoke(x) |> string) @@>



                                      ctx.JsonRuntimeType?(nameof (JsonRuntime2.GetHeterogeneousValue))
                                          (result.RepresentationTypeErased ctx)
                                          (arg, result.ConverterFunc ctx)

                              //{ RepresentationType = elementTypeResult.RepresentationType.MakeArrayType()
                              //    OptionalConverter = Some (fun arg ->
                              //        ctx.JsonRuntimeType?(nameof (JsonRuntime2.GetArrayValues))
                              //            (elementTypeResult.RepresentationTypeErased ctx)
                              //            (arg, elementTypeResult.ConverterFunc ctx))
                              //    //ConversionCallingType = JsonDocument
                              //    }

                              ProvidedProperty(name, typ, getterCode = getter),
                              (ProvidedParameter(NameUtils.niceCamelName name, constructorType),
                               findOriginalPrimitiveType inferedType) ]

                    let properties, paramsTuple = List.unzip members
                    objectTy.AddMembers properties

                    if ctx.GenerateConstructors then

                        let cultureStr = ctx.CultureStr

                        for param, originalPrimitiveType in paramsTuple do
                            let ctorCode (Singleton arg: Expr list) = <@@ () @@>
                            //let arg = Expr.Coerce(arg, typeof<obj>)
                            //let serializedOriginalPrimitiveType =
                            //    originalPrimitiveType |> PrimitiveType.ToInt
                            //<@@ Some <| JsonRuntime2.CreateValue((%%arg: obj), serializedOriginalPrimitiveType, cultureStr) @@>

                            let ctor = ProvidedConstructor([ param ], invokeCode = ctorCode)
                            objectTy.AddMember ctor

                        match containsOptional with
                        | InferedOptionality.Optional NullKind.NoValue ->
                            let defaultCtor =
                                let ctorCode _ = <@@ None @@>

                                ProvidedConstructor([], invokeCode = ctorCode)

                            objectTy.AddMember defaultCtor
                        | InferedOptionality.Optional NullKind.NullToken ->
                            let defaultCtor =
                                let ctorCode _ = <@@ () @@>
                                //let noPrimitiveType = None |> PrimitiveType.ToInt
                                //<@@ Some <| JsonRuntime2.CreateValue(null :> obj, noPrimitiveType, cultureStr) @@>

                                ProvidedConstructor([], invokeCode = ctorCode)

                            objectTy.AddMember defaultCtor
                        | _ -> ()

                        let ctorCode (Singleton arg) = <@@ () @@>
                        //<@@ Some <| JsonDocument2.Create((%%arg: JsonValue2), "") @@>

                        let ctor =
                            ProvidedConstructor(
                                [ ProvidedParameter("jsonValue", ctx.JsonWrapperType) ],
                                invokeCode = ctorCode
                            )

                        objectTy.AddMember ctor

                    objectTy

                //generateMultipleChoiceType ctx types containsOptional nameOverride (fun result tagCode ->
                //    fun (Singleton jDoc) ->
                //        let cultureStr = ctx.CultureStr

                //        //ctx.JsonRuntimeType?(nameof (JsonRuntime2.TryGetValueByTypeTag))
                //        //    (result.RepresentationTypeErased ctx)
                //        //    (jDoc, cultureStr, tagCode, result.ConverterFunc ctx)
                //        <@@ () @@>
                //            )
                //            )
                )

            //let conv =
            //    // converts jvalue option to jdocument option
            //    fun (jDoc: Expr) ->
            //        ctx.JsonRuntimeType?(nameof (JsonRuntime2.ConvertOptionalValue))
            //            (result.RepresentationTypeErased ctx)
            //            (jDoc, result.ConverterFunc ctx)

            //let conv =
            //    fun (arg: Expr) ->
            //        // heterogeneous types are always backed by a JsonWrapper option.
            //        <@@ JsonRuntime2.GetAsOptional(%%arg) @@>

            { RepresentationType = providedHeterogeneousType
              // heterogeneous types are always backed by a JsonWrapper option.
              OptionalConverter = Some(fun (arg: Expr) -> <@@ JsonRuntime2.GetAsOptional(%%arg) @@>)
            //ConversionCallingType = JsonConversionCallingType2.JsonDocumentOption
            }
        | InferedType.Json _ -> failwith "Json type not supported"
